/* exported Chart, constant, draw */

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var svg_ns = "http://www.w3.org/2000/svg";
var global = window;

function noop() {}

function constant(val) {
  return function constant() {
    return val;
  };
}

function each(object, callback) {
  for (var key in object) {
    if (object.hasOwnProperty(key)) callback(key, object[key]);
  }
}

function parse_event(event) {
  var name = '',
      type = event,
      i = event.indexOf('.');
  if (i >= 0) {
    name = event.slice(i + 1) || '*';
    type = event.slice(0, i) || '*';
  }
  return { name: name, type: type };
}

var CHILDREN = '_children',
    CALLBACKS = '_callbacks',
    LINKCOUNT = '_linkcount',
    PROPERTIES = '_properties';

var Dispatcher = function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    Object.defineProperty(this, PROPERTIES, { value: {}, __proto__: null });
    Object.defineProperty(this, CALLBACKS, { value: [], __proto__: null });
  }

  // .prop('x')              // creates a property .x()
  // .x(value)               // sets x to value.
  // .x()                    // returns value.
  // .prop('x', 'y')         // Defines x() storing it in this.y
  // .prop('x', fn)          // Defines x() storing it fn() -- another property
  // .prop({x: x1, y: y1})   // Same as .prop('x', x1).prop('y', y1)
  // .prop(['x', 'y'])       // Same as .prop('x').prop('y')
  // If the target has no value, existing values are propogated
  // Requires .trigger()


  _createClass(Dispatcher, [{
    key: "prop",
    value: function prop(key, variable) {
      var self = this;

      // prop() => {all properties and values}
      if (arguments.length == 0) {
        var result = {};
        each(self[PROPERTIES], function (key) {
          result[key] = self[key]();
        });
        return result;
      }

      // prop(['x', 'y']) => prop('x').prop('y')
      if (Array.isArray(key)) {
        key.forEach(function (val) {
          self.prop(val);
        });
        return self;
      }
      // prop({x: x1, y: y1}) => prop('x', x1).prop('y', y1)
      if ((typeof key === "undefined" ? "undefined" : _typeof(key)) == 'object') {
        each(key, self.prop.bind(self));
        return self;
      }
      // prop('x') => prop('x', '_x')
      if (arguments.length == 1) variable = "_" + key;

      // Get the old value if it exists
      var old_value;
      if (typeof self[key] == 'function') old_value = self[key]();

      // prop('x', 'a') stores .x() in self.a
      if (typeof variable == 'string') {
        self[key] = function (value) {
          if (arguments.length == 0) return self[variable];else if (value === null) delete self[variable];else self[variable] = value;
          return self.trigger(key, value, key);
        };
      }
      // prop('x', fn) stores .x() in getter-setter fn()
      else if (typeof variable == 'function') {
          self[key] = function (value) {
            if (arguments.length == 0) return variable();
            variable(value);
            return self.trigger(key, value, key);
          };
        }
        // prop('x', obj) stores .x() in dictionary, updating it when set
        else if ((typeof variable === "undefined" ? "undefined" : _typeof(variable)) == 'object') {
            self[key] = function (value) {
              if (arguments.length == 0) return variable;
              // .x(null) clears all keys
              if (value === null) each(variable, function (key) {
                delete variable[key];
              });
              // .x({key: val}) sets obj[key] = val
              else if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == 'object') each(value, function (key, val) {
                  if (val === null) delete variable[key];else variable[key] = val;
                });
                // .x(value) sets all existig keys to value
                else each(variable, function (key) {
                    variable[key] = value;
                  });
              return self.trigger(key, variable, key);
            };
          } else throw new TypeError("Invalid value: .prop(\"" + key + "\", " + variable + ")");

      // Store the created property and its target location
      self[PROPERTIES][key] = variable;

      // Save the old value into the target if the target has no value
      if (typeof self[key]() == 'undefined' && typeof old_value != 'undefined') self[key](old_value);

      return self;
    }

    // .call(callback) runs callback(this) and then returns this
    // Useful for chaining

  }, {
    key: "call",
    value: function call(callback) {
      callback(this);
      return this;
    }

    // .trigger('x', arg1, arg2, ...)  // trigger all callbacks on x with arguments
    // Requires .on() in CALLBACKS

  }, {
    key: "trigger",
    value: function trigger(event) {
      var parsed = parse_event(event),
          type = parsed.type,
          args = Array.from(arguments).slice(1),
          self = this;
      if (type) self.on(type + ".*").forEach(function (row) {
        row[2].apply(self, args);
      });
      return self;
    }
  }]);

  return Dispatcher;
}();

add_namespaced_store(Dispatcher, 'on', CALLBACKS, function (val) {
  return typeof val == 'function';
});

var Container = function (_Dispatcher) {
  _inherits(Container, _Dispatcher);

  function Container() {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this));

    Object.defineProperty(_this, CHILDREN, { value: [], __proto__: null });
    Object.defineProperty(_this, LINKCOUNT, { value: 0, __proto__: null, writable: true });
    return _this;
  }

  // container.link('x', [container1, 'x'], [container2, 'x1'], ...) links this
  // container's .x() to container1.x() and container2.x1(). They behave as the
  // same property. In fact, they are stored behind the scenes in container.x().


  _createClass(Container, [{
    key: "link",
    value: function link(prop, containers) {
      var self = this;
      // container.link(['x', 'y'], [container1, container2])
      // links .x() and .y() across container1 and container2
      if (Array.isArray(prop) && Array.isArray(containers)) {
        prop.forEach(function (prop) {
          var args = [prop];
          for (var i = 0, l = containers.length; i < l; i++) {
            args.push([containers[i], prop]);
          }self.link.apply(self, args);
        });
        return self;
      }

      var links = Array.from(arguments).slice(1);
      // Create property if required
      if (!self[prop]) self.prop(prop);
      // Save each linked container's property into this container's property
      links = links.map(function (link) {
        var target = link[0];
        // .link('prop', ['child-name', 'prop'])
        if (typeof target == 'string') target = self.child(target) || target;
        // .link('prop', [container, 'prop'])
        if (typeof target.prop == 'function') target.prop(link[1], self[prop]);
        return [target, link[1]];
      });
      // When this container's property changes, trigger all linked containers'
      // properties. Use LINKCOUNT to ensure the events have a unique namespace.
      self.on(prop + ".link" + self[LINKCOUNT]++, function (val) {
        for (var i = 0, l = links.length; i < l; i++) {
          links[i][0].trigger(links[i][1], val, links[i][1]);
        }
      });
      return self;
    }

    // Create / link specified properties from children
    // .childprop(prop1, prop2, ...)

  }, {
    key: "childprop",
    value: function childprop() {
      var self = this,
          children = this.child(),
          props = children.map(function (row) {
        return row[2].prop();
      });
      Array.from(arguments).forEach(function (prop) {
        self.link([prop], children.filter(function (row, i) {
          return props[i].hasOwnProperty(prop);
        }).map(function (row) {
          return row[2];
        }));
      });
      return self;
    }
  }]);

  return Container;
}(Dispatcher);

add_namespaced_store(Container, 'child', CHILDREN);

// The methods used to determine the size of a node, in order.
var size_methods = {
  // For SVG elements, use the viewBox or computed width/height of nearest SVG parent
  svg: function svg(node) {
    if (node.namespaceURI && node.namespaceURI == svg_ns) {
      while (!node.nodeName.match(/svg/i)) {
        node = node.parentNode;
      }if (node.getAttribute('viewBox')) return node.viewBox.baseVal;else return { width: node.width.baseVal.value, height: node.height.baseVal.value };
    }
  },
  bounds: function bounds(node) {
    if (node.getBoundingClientRect) return node.getBoundingClientRect();
  }
};

// Return {x, y, width, height} given a chart and its size
//
var attrs = ['top', 'left', 'bottom', 'right'];
function padded(chart, dimensions) {
  var pad = chart.padding() || {};
  if (typeof pad == 'function') pad = pad(dimensions);
  attrs.forEach(function (attr) {
    if (typeof pad[attr] == 'function') pad[attr] = pad[attr](dimensions);
    if (typeof pad[attr] !== 'number') pad[attr] = 0;
  });
  return {
    left: pad.left,
    top: pad.top,
    width: dimensions.width - pad.left - pad.right,
    height: dimensions.height - pad.top - pad.bottom
  };
}

var name_count = 0;

var Chart = function (_Container) {
  _inherits(Chart, _Container);

  function Chart(options) {
    _classCallCheck(this, Chart);

    var _this2 = _possibleConstructorReturn(this, (Chart.__proto__ || Object.getPrototypeOf(Chart)).call(this));

    _this2.options = options || {};
    _this2.options.name = _this2.options.name || "name_" + name_count++;
    _this2.prop(['data', 'update', 'enter', 'exit']).prop('padding', { left: 0, right: 0, top: 0, bottom: 0 })
    // .defined() is a function that returns true if a row is to be drawn
    .prop('defined').defined(constant(true));
    return _this2;
  }

  // chart.size(node) returns the size of a node by successively trying size methods.
  // If it's unable to get the size, returns {width: 0, height: 0}


  _createClass(Chart, [{
    key: "size",
    value: function size(node) {
      for (var key in size_methods) {
        if (size_methods.hasOwnProperty(key)) {
          var size = size_methods[key](node);
          if (size && size.width > 0 && size.height > 0) return padded(this, size);
        }
      }var parent = node.parentNode;
      if (parent) return this.size(parent);
      return { width: 0, height: 0 };
    }

    // chart.draw() calls all child .draw() functions, and then this.on('draw') handlers
    // chart.draw() can be called with a string selector, node list or node

  }, {
    key: "draw",
    value: function draw(node) {
      // Select a single node as a selector, d3 selection or DOM node
      if (typeof node == 'string') // selector
        node = document.querySelector(node);else if (typeof node.node == 'function') // d3 selection
        node = node.node();else if (!(node instanceof Node)) // node
        throw new TypeError('.draw() needs a single selector, node or d3 selection');
      // Trigger the pre-draw event before starting
      this.trigger('predraw', node, 'predraw');
      // Draw all sub-components
      this.child().forEach(function (row) {
        var name = row[0],
            chart = row[2],
            type = [],
            tag_regex = /^\s*<\s*(.*?)\s*>\s*$/,
            tag;

        row[1].split('.').forEach(function (type_tag) {
          var match = tag_regex.exec(type_tag);
          if (match) tag = match[1];else type.push(type_tag);
        });
        type = type.join('.');

        var selector = "." + name + (type ? "." + type : ''),
            cls = name + (type ? " " + type.replace('.', ' ') : '');

        // Match or create sub node with the same name
        var ns = node.namespaceURI;
        var subnode = node.querySelector(selector);
        // Create the subnode if it doesn't exist
        if (subnode === null) {
          // Use a G or DIV tag if none is specified
          tag = tag || (ns.match(/svg/) ? 'g' : 'div');
          // When creating a tag inside an SVG element, or create an SVG element, use SVG namespace
          // Else do not use a namespace
          if (ns.match(/svg/i) || tag.match(/^svg$/i)) subnode = document.createElementNS(svg_ns, tag);else subnode = document.createElement(tag);
          subnode.setAttribute('class', cls);
          node.appendChild(subnode);
        }
        if (typeof chart.draw == 'function') chart.draw(subnode);
      });
      // Trigger the draw event when done
      return this.trigger('draw', node, 'draw');
    }

    // .join() is a shortcut for .on('predraw.join', join(...))

  }, {
    key: "join",
    value: function join(selector, data) {
      return this.on('predraw.join', global.join(selector, data));
    }
  }]);

  return Chart;
}(Container);

// Returns a method that does a data join on data. For example:
// join('g.vertical', chart.data)
// returns a function(node) that creates joins `g.vertical` with chart.data()
// and adds the enter, update, exit properties to the chart.


global.join = function (selector, data) {
  selector = selector || '';

  var _selector$split = selector.split('.'),
      _selector$split2 = _toArray(_selector$split),
      tag = _selector$split2[0],
      cls = _selector$split2.slice(1);

  cls = cls.join(' ');
  return function (node) {
    var name = this.options.name,
        join = d3.select(node).selectAll(selector + '.' + name).data((data || this.data)());
    var enter = join.enter().append(tag || (node.namespaceURI.match(/svg/) ? 'g' : 'div')).classed(cls + ' ' + name, true);
    var exit = join.exit().remove();
    // D3 4.0 uses enter.merge(join). D3 3.0 uses just the join
    this.update(typeof enter.merge == 'function' ? enter.merge(join) : join);
    this.enter(enter);
    this.exit(exit);
  };
};

// Ensure that a single selector=tag.class exists in all joined nodes.
// Call the callback on these selectors as an update.
global.draw = function (selector, callback) {
  var _selector$split3 = selector.split('.'),
      _selector$split4 = _toArray(_selector$split3),
      tag = _selector$split4[0],
      cls = _selector$split4.slice(1);

  cls = cls.join(' ');
  if (typeof callback != 'function') callback = noop;
  return function () {
    var update = this.update().filter(this.defined()).each(function () {
      var self = d3.select(this);
      if (self.select(selector).node() === null) self.append(tag).classed(cls, true);
    }).select(selector);
    callback.call(this, update);
  };
};

// Create cls.method that stores values in attr
function add_namespaced_store(cls, method, attr, check) {
  Object.defineProperty(cls.prototype, method, { value: getter_setter, __proto__: null });

  function getter_setter(event, val, order) {
    var self = this;

    // .method([key1, key2], val, order) => .method(key1, val, order).method(key2, val, order)
    if (Array.isArray(event)) {
      event.forEach(function (ev) {
        getter_setter.bind(self)(ev, val, order);
      });
      return self;
    }

    // .method({key: val, key:val}) => .method(key, val).method(key, val)
    if ((typeof event === "undefined" ? "undefined" : _typeof(event)) == 'object') {
      each(event, getter_setter.bind(self));
      return self;
    }

    // If event is "type.name", set type, name variables appropriately
    var container = self[attr],
        parsed = parse_event(event || '.'),
        type = parsed.type,
        name = parsed.name,
        all_types = type == '*',
        all_names = name == '*',
        i,
        row,
        added,
        match;
    // .method('x')               // returns val for type x, namespace ''
    // .method('x.?')             // returns val for first item of type x
    // .method('x.a')             // returns val of type x, namespace a
    // .method('?.a')             // returns val for first item of namespace a
    // .method('.a'), ('*.a')     // returns list of val with namespace a
    // .method('x.'), ('x.*')     // returns list of val with type x
    if (arguments.length <= 1) {
      if (all_types && all_names) return container;else if (all_types) return container.filter(function (row) {
        return row[1] == name;
      });else if (all_names) return container.filter(function (row) {
        return row[0] == type;
      });else {
        if (name == '?') match = container.filter(function (row) {
          return row[0] == type;
        });else if (type == '?') match = container.filter(function (row) {
          return row[1] == name;
        });else match = container.filter(function (row) {
          return row[0] == type && row[1] == name;
        });
        return match.length > 0 ? match[0][2] : match[0];
      }

      // .method('x', null)        // clears val type x, namespace ''
      // .method('x.a', null)      // clears val type x, namespace a
      // .method('.a', null)       // clears all vals with namespace a

    } else if (val === null) {
        if (all_types && all_names) container.length = 0;else if (all_types) for (i = container.length, row; i--;) {
          row = container[i];
          if (row[1] == name) container.splice(i, 1);
        } else if (all_names) for (i = container.length, row; i--;) {
          row = container[i];
          if (row[0] == type) container.splice(i, 1);
        } else for (i = container.length, row; i--;) {
          row = container[i];
          if (row[0] == type && row[1] == name) container.splice(i, 1);
        }
      }

      // .method('x', val, order)       // sets type x, namespace '' to val at order
      // .method('x.a', val, order)     // sets type x, namespace a to val at order
      // .method('x', noop, order)      // re-order existing 'x' to order
      else if (type && !all_types) {
          if (typeof check == 'function' && !check(val)) throw new TypeError("." + method + "(\"" + event + "\", " + val + ") has an invalid value");
          if (typeof order != 'undefined' && typeof order != 'number') throw new TypeError("." + method + "(\"" + event + "\", " + val + ", " + order + "): " + order + " be a number");
          for (i = 0, added = null, row; row = container[i]; i++) {
            if (row[0] == type && row[1] == name) {
              added = row[2] = val === noop ? row[2] : val;
              if (typeof order == 'number' && order != i)
                // Move from position `i` to position `order`
                container.splice(order, 0, container.splice(i, 1)[0]);
            }
          }if (added === null) {
            // insert new row at position `order` -- or at the end
            container.splice(typeof order == 'number' ? order : container.length, 0, [type, name, val]);
          }
        } else throw new TypeError("." + method + "(\"" + event + "\", ...) is invalid. Use \"<type>.<name>\"");

    return self;
  }
}
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global Chart, constant, draw */
/* exported Axis, VerticalChart, BarChart, LineChart CombChart, AreaChart, ScatterLineChart */

var _axis_map = {
  'top': d3.axisTop,
  'bottom': d3.axisBottom,
  'left': d3.axisLeft,
  'right': d3.axisRight
};
var _curve_map = {
  'linear': d3.curveLinear,
  'linear-closed': d3.curveLinearClosed,
  'step': d3.curveStep,
  'step-after': d3.curveStepAfter,
  'step-before': d3.curveStepBefore,
  'basis': d3.curveBasis,
  'basis-open': d3.curveBasisOpen,
  'basis-closed': d3.curveBasisClosed,
  'bundle': d3.curveBundle,
  'cardinal': d3.curveCardinal,
  'cardinal-open': d3.curveCardinalOpen,
  'cardinal-closed': d3.curveCardinalClosed,
  'monotone': d3.curveMonotoneX
};

var _scale_info = {
  linear: { scale: d3.scaleLinear, ordinal: false, accessor: constant(0) },
  pow: { scale: d3.scalePow, ordinal: false, accessor: constant(0) },
  sqrt: { scale: d3.scaleSqrt, ordinal: false, accessor: constant(0) },
  log: { scale: d3.scaleLog, ordinal: false, accessor: constant(1) },
  time: { scale: d3.scaleTime, ordinal: false, accessor: constant(new Date()) },
  point: { scale: d3.scalePoint, ordinal: true, accessor: function accessor(d, i) {
      return i;
    } },
  band: { scale: d3.scaleBand, ordinal: true, accessor: function accessor(d, i) {
      return i;
    } }
};

// Returns a function that extends the domain of an axis
// setup: this.xextend = domain_extender(this, 'x', true)   // creates an ordinal extender for x
// usage: this.xextend()                                    // extends .xscale().domain() using data
function domain_extender(self, axis, ordinal) {
  var scalename = axis + 'scale',
      zero = axis + '0',
      zero_val = axis + '0_value';
  if (ordinal) return function () {
    var scale_prop = self[scalename],
        scale = scale_prop(),
        domain = self.data().map(self[axis]());
    if (scale_prop._has_domain) {
      var old_domain = scale.domain(),
          add_values = domain.filter(function (val) {
        return old_domain.indexOf(val) < 0;
      });
      scale.domain(old_domain.concat(add_values));
    } else {
      scale.domain(domain);
      scale_prop._has_domain = true;
    }
    return scale;
  };else return function () {
    var scale_prop = self[scalename],
        scale = scale_prop(),
        domain = d3.extent(self.data(), self[axis]());

    // Incorporate the zero value
    var z = self[zero]();
    if (typeof z != 'undefined') {
      if (domain[0] > z) domain[0] = z;
      if (domain[1] < z) domain[1] = z;
    } else {
      z = domain[0];
    }
    self[zero_val] = z;

    // Extend the domain
    if (scale_prop._has_domain) scale.domain(d3.extent([].concat(_toConsumableArray(scale.domain()), _toConsumableArray(domain))));else {
      scale.domain(domain);
      scale_prop._has_domain = true;
    }
    return scale;
  };
}

var Axis = function (_Chart) {
  _inherits(Axis, _Chart);

  function Axis(options) {
    _classCallCheck(this, Axis);

    var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this, options));

    var orient = _this.options.orient || 'bottom';
    _this.prop('axis').axis(_axis_map[orient]()).prop('scale').scale(d3.scaleIdentity()).prop('position').on('draw.axis', _this.render);
    return _this;
  }

  _createClass(Axis, [{
    key: 'render',
    value: function render(node) {
      var axis = this.axis().scale(this.scale());
      d3.select(node).call(axis);
    }
  }]);

  return Axis;
}(Chart);

var XYChart = function (_Chart2) {
  _inherits(XYChart, _Chart2);

  function XYChart(options) {
    _classCallCheck(this, XYChart);

    // Valid options:
    //    .xscale: linear/pow/sqrt/point/band
    //    .yscale: linear/pow/sqrt/point/band
    //    .xaxis: top/left/bottom/right (required for scale)
    //    .yaxis: top/left/bottom/right (required for scale)
    options = Object.assign({ xscale: 'linear', yscale: 'linear', xaxis: 'bottom', yaxis: 'left' }, options);

    // Defines .xscale(), .yscale(), .x() and .y() properties with defaults.
    var _this2 = _possibleConstructorReturn(this, (XYChart.__proto__ || Object.getPrototypeOf(XYChart)).call(this, options));

    options.x = _scale_info[options.xscale];
    options.y = _scale_info[options.yscale];
    _this2.prop('xscale').xscale(options.x.scale()).prop('x').x(options.x.accessor).prop('yscale').yscale(options.y.scale()).prop('y').y(options.y.accessor)

    // .interpolate() is the string interpolation value to use for curves
    .prop('interpolate').interpolate('linear')

    // .layout() creates a .pos object in each row that defines its x, y, width, height
    // .join() creates .enter, .update, .exit properties by joining on this chart's name
    // .axes() moves the axes to the right position (top/bottom/left/right)
    // .render() is an abstract rendering function for this class
    .on('predraw.layout', _this2.layout).join().on('draw.axes', _this2.axes).on('draw.render', _this2.render);

    // Additional properties for continous scales
    if (!options.x.ordinal) _this2.prop('x0');
    if (!options.y.ordinal) _this2.prop('y0');

    // this.xextend() extends .xscale().domain() based on new data
    _this2.xextend = domain_extender(_this2, 'x', options.x.ordinal);
    _this2.yextend = domain_extender(_this2, 'y', options.y.ordinal);

    _this2.child('xaxis', new Axis({ orient: options.xaxis })).link('xscale', ['xaxis', 'scale']);
    _this2.child('yaxis', new Axis({ orient: options.yaxis })).link('yscale', ['yaxis', 'scale']);

    if (options.labels) _this2.child('labels', new Chart().join('.label')).link(['data', 'defined', 'x', 'y'], ['labels']).child('labels').on('draw.render', _this2.labels);
    return _this2;
  }

  _createClass(XYChart, [{
    key: 'layout',
    value: function layout(node) {
      var data = this.data(),
          x = this.x(),
          y = this.y(),
          size = this.size(node),
          xscale = this.xextend(),
          yscale = this.yextend(),
          bandwidth,
          zero_pos;

      xscale.range(this.options.yaxis == 'right' ? [size.left + size.width, size.width] : [size.left, size.left + size.width]);
      yscale.range(this.options.xaxis == 'bottom' ? [size.top + size.height, size.top] : [size.top, size.top + size.height]);
      data.forEach(function (d, i) {
        d.pos = {
          x: +xscale(x(d, i)),
          y: +yscale(y(d, i))
        };
      });
      if (this.options.x.ordinal) {
        bandwidth = +xscale.bandwidth();
        data.forEach(function (d) {
          d.pos.x1 = d.pos.x + bandwidth;
        });
      } else {
        zero_pos = +xscale(this.x0_value);
        data.forEach(function (d) {
          d.pos.x1 = zero_pos;
        });
      }
      if (this.options.y.ordinal) {
        bandwidth = +yscale.bandwidth();
        data.forEach(function (d) {
          d.pos.y1 = d.pos.y + bandwidth;
        });
      } else {
        zero_pos = +yscale(this.y0_value);
        data.forEach(function (d) {
          d.pos.y1 = zero_pos;
        });
      }
    }
  }, {
    key: 'axes',
    value: function axes(node) {
      var size = this.size(node);
      // Position ordinal axes at the top/left, continous axes at the zero position
      d3.select(node).select('.yaxis').attr('transform', 'translate(' + (this.options.x.ordinal ? size.left : this.xscale()(this.x0_value)) + ',0)');
      d3.select(node).select('.xaxis').attr('transform', 'translate(0,' + (this.options.y.ordinal ? size.top : this.yscale()(this.y0_value)) + ')');
    }
  }, {
    key: 'render',
    value: function render() {}
  }]);

  return XYChart;
}(Chart);

var VerticalChart = function (_XYChart) {
  _inherits(VerticalChart, _XYChart);

  function VerticalChart(options) {
    _classCallCheck(this, VerticalChart);

    options = Object.assign({
      name: 'vertical',
      xscale: 'band',
      yscale: 'linear',
      xaxis: 'bottom',
      yaxis: 'left'
    }, options);
    return _possibleConstructorReturn(this, (VerticalChart.__proto__ || Object.getPrototypeOf(VerticalChart)).call(this, options));
  }

  return VerticalChart;
}(XYChart);

VerticalChart.prototype.labels = draw('text.vertical-label', function (update) {
  var _this4 = this;

  var y = this.y();
  update.attr('transform', function (d) {
    return 'translate(' + (d.pos.x + d.pos.x1) / 2 + ',' + d.pos.y + ')';
  }).attr('text-anchor', 'middle')
  // If y0_value is undefined, treat y(d) as above y0_value
  .attr('dy', function (d) {
    return y(d) < _this4.y0_value ? '1em' : '-0.37em';
  }).text(function (d) {
    return y(d);
  });
});

var JitterChart = function (_VerticalChart) {
  _inherits(JitterChart, _VerticalChart);

  function JitterChart() {
    _classCallCheck(this, JitterChart);

    return _possibleConstructorReturn(this, (JitterChart.__proto__ || Object.getPrototypeOf(JitterChart)).apply(this, arguments));
  }

  return JitterChart;
}(VerticalChart);

JitterChart.prototype.render = draw('circle.dot', function (update) {
  // Moves the circle randomly along the horizontal axis
  update.attr('cx', function (d) {
    return d.pos.x + Math.random() * (d.pos.x1 - d.pos.x);
  }).attr('cy', function (d) {
    return d.pos.y;
  }).attr('r', 1);
});

var BarChart = function (_VerticalChart2) {
  _inherits(BarChart, _VerticalChart2);

  function BarChart() {
    _classCallCheck(this, BarChart);

    return _possibleConstructorReturn(this, (BarChart.__proto__ || Object.getPrototypeOf(BarChart)).apply(this, arguments));
  }

  return BarChart;
}(VerticalChart);

BarChart.prototype.render = draw('path.bar', _draw_rect);

var CombChart = function (_VerticalChart3) {
  _inherits(CombChart, _VerticalChart3);

  function CombChart() {
    _classCallCheck(this, CombChart);

    return _possibleConstructorReturn(this, (CombChart.__proto__ || Object.getPrototypeOf(CombChart)).apply(this, arguments));
  }

  return CombChart;
}(VerticalChart);

CombChart.prototype.render = draw('path.comb', function (update) {
  update.attr('d', function (d) {
    return 'M' + (d.pos.x + d.pos.x1) / 2 + ',' + d.pos.y + 'V' + d.pos.y1;
  });
});

var LineChart = function (_VerticalChart4) {
  _inherits(LineChart, _VerticalChart4);

  function LineChart(options) {
    _classCallCheck(this, LineChart);

    // TODO: this is a hack
    var _this8 = _possibleConstructorReturn(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).call(this, options));

    _this8.join('.line', constant([0]));
    return _this8;
  }

  _createClass(LineChart, [{
    key: 'render',
    value: function render() {
      var path = d3.line().defined(this.defined()).x(function (d) {
        return (d.pos.x + d.pos.x1) / 2;
      }).y(function (d) {
        return d.pos.y;
      }).curve(_curve_map[this.interpolate()]);
      this.enter().append('path').classed('line', true);
      this.update().select('.line').attr('d', path(this.data()));
    }
  }]);

  return LineChart;
}(VerticalChart);

var AreaChart = function (_LineChart) {
  _inherits(AreaChart, _LineChart);

  function AreaChart(options) {
    _classCallCheck(this, AreaChart);

    options = Object.assign({ xscale: 'point' }, options);
    return _possibleConstructorReturn(this, (AreaChart.__proto__ || Object.getPrototypeOf(AreaChart)).call(this, options));
  }

  _createClass(AreaChart, [{
    key: 'render',
    value: function render() {
      var data = this.data();
      var path = d3.area().defined(this.defined()).x(function (d) {
        return (d.pos.x + d.pos.x1) / 2;
      }).y1(function (d) {
        return d.pos.y;
      }).curve(_curve_map[this.interpolate()]);
      path.y0(this.yscale()(this.y0_value));

      this.enter().append('path').classed('area', true);
      this.update().select('.area').attr('d', path(data));
    }
  }]);

  return AreaChart;
}(LineChart);

var MatrixChart = function (_XYChart2) {
  _inherits(MatrixChart, _XYChart2);

  function MatrixChart(options) {
    _classCallCheck(this, MatrixChart);

    options = Object.assign({
      name: 'grid',
      xscale: 'band',
      yscale: 'band',
      xaxis: 'top',
      yaxis: 'left'
    }, options);
    return _possibleConstructorReturn(this, (MatrixChart.__proto__ || Object.getPrototypeOf(MatrixChart)).call(this, options));
  }

  return MatrixChart;
}(XYChart);

var DotChart = function (_MatrixChart) {
  _inherits(DotChart, _MatrixChart);

  function DotChart() {
    _classCallCheck(this, DotChart);

    return _possibleConstructorReturn(this, (DotChart.__proto__ || Object.getPrototypeOf(DotChart)).apply(this, arguments));
  }

  return DotChart;
}(MatrixChart);

DotChart.prototype.render = draw('circle.dot', function (update) {
  update.attr('cx', function (d) {
    return (d.pos.x + d.pos.x1) / 2;
  }).attr('cy', function (d) {
    return (d.pos.y + d.pos.y1) / 2;
  }).attr('r', 1);
});

var GridChart = function (_MatrixChart2) {
  _inherits(GridChart, _MatrixChart2);

  function GridChart() {
    _classCallCheck(this, GridChart);

    return _possibleConstructorReturn(this, (GridChart.__proto__ || Object.getPrototypeOf(GridChart)).apply(this, arguments));
  }

  return GridChart;
}(MatrixChart);

GridChart.prototype.render = draw('path.grid', _draw_rect);

var HorizontalChart = function (_XYChart3) {
  _inherits(HorizontalChart, _XYChart3);

  function HorizontalChart(options) {
    _classCallCheck(this, HorizontalChart);

    options = Object.assign({
      name: 'horizontal',
      xscale: 'linear',
      yscale: 'band',
      xaxis: 'top',
      yaxis: 'left'
    }, options);
    return _possibleConstructorReturn(this, (HorizontalChart.__proto__ || Object.getPrototypeOf(HorizontalChart)).call(this, options));
  }

  return HorizontalChart;
}(XYChart);

var HorizontalBarChart = function (_HorizontalChart) {
  _inherits(HorizontalBarChart, _HorizontalChart);

  function HorizontalBarChart() {
    _classCallCheck(this, HorizontalBarChart);

    return _possibleConstructorReturn(this, (HorizontalBarChart.__proto__ || Object.getPrototypeOf(HorizontalBarChart)).apply(this, arguments));
  }

  return HorizontalBarChart;
}(HorizontalChart);

HorizontalBarChart.prototype.render = draw('path.horizontalbar', _draw_rect);

var HorizontalCombChart = function (_HorizontalChart2) {
  _inherits(HorizontalCombChart, _HorizontalChart2);

  function HorizontalCombChart() {
    _classCallCheck(this, HorizontalCombChart);

    return _possibleConstructorReturn(this, (HorizontalCombChart.__proto__ || Object.getPrototypeOf(HorizontalCombChart)).apply(this, arguments));
  }

  return HorizontalCombChart;
}(HorizontalChart);

HorizontalCombChart.prototype.render = draw('path.horizontalcomb', function (update) {
  update.attr('d', function (d) {
    return 'M' + d.pos.x + ',' + (d.pos.y + d.pos.y1) / 2 + 'H' + d.pos.x1;
  });
});

var PointChart = function (_XYChart4) {
  _inherits(PointChart, _XYChart4);

  function PointChart(options) {
    _classCallCheck(this, PointChart);

    options = Object.assign({
      name: 'point',
      xscale: 'linear',
      yscale: 'linear',
      xaxis: 'bottom',
      yaxis: 'left'
    }, options);
    return _possibleConstructorReturn(this, (PointChart.__proto__ || Object.getPrototypeOf(PointChart)).call(this, options));
  }

  return PointChart;
}(XYChart);

var ScatterChart = function (_PointChart) {
  _inherits(ScatterChart, _PointChart);

  function ScatterChart() {
    _classCallCheck(this, ScatterChart);

    return _possibleConstructorReturn(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).apply(this, arguments));
  }

  return ScatterChart;
}(PointChart);

ScatterChart.prototype.render = draw('circle.dot', function (update) {
  update.attr('cx', function (d) {
    return d.pos.x;
  }).attr('cy', function (d) {
    return d.pos.y;
  }).attr('r', 1);
});

var ScatterLineChart = function (_ScatterChart) {
  _inherits(ScatterLineChart, _ScatterChart);

  function ScatterLineChart(options) {
    _classCallCheck(this, ScatterLineChart);

    var _this18 = _possibleConstructorReturn(this, (ScatterLineChart.__proto__ || Object.getPrototypeOf(ScatterLineChart)).call(this, options));

    _this18.join('.line', constant([0]));
    return _this18;
  }

  _createClass(ScatterLineChart, [{
    key: 'render',
    value: function render() {
      var path = d3.line().defined(this.defined()).x(function (d) {
        return d.pos.x;
      }).y(function (d) {
        return d.pos.y;
      }).curve(_curve_map[this.interpolate()]);
      this.enter().append('path').classed('line', true);
      this.update().select('.line').attr('d', path(this.data()));
    }
  }]);

  return ScatterLineChart;
}(ScatterChart);

function _draw_rect(update) {
  var interpolate = this.interpolate();
  update.attr('d', function (d) {
    var p = d.pos;
    return d3.line().curve(_curve_map[interpolate])([[p.x, p.y1], [p.x, p.y], [p.x1, p.y], [p.x1, p.y1]]);
  });
}
