/* globals Chart */
/* exported Treemap */

class Treemap extends Chart {
  constructor(options) {
    super(options)

    // Define all the properties for the treemap
    this.prop('treemap')
        .prop('id')
        .prop('parentId')
        .prop('sum')
        .prop('sort')
        .prop('color')

    this.on('predraw.layout', this.layout)
        .on('predraw.create', this.create)
        .on('draw.render', this.render)
  }

  layout(node) {
    var data = this.data(),
        id = this.id(),
        parentId = this.parentId(),
        sum = this.sum(),
        sort = this.sort()

    var size = this.size(node)
    // Set the width & height according to the size of the container
    var treemap = this.treemap()
      .size([size.width, size.height])

    // Convert the data to a hierarchial layout
    var root = d3.stratify()
      .id(id)
      .parentId(parentId)

    // Specify the sum and sort value parameters
    root(data)
      .sum(sum)
      .sort(sort)

    // Add layout points to the data
    treemap(root)
    this.data(root)
  }

  create(node) {
    var join = d3.select(node)
        .selectAll('.node.' + this.options.name)
        .data(this.data().leaves())
    var enter = join.enter()
        .append('g')
        .classed('node', true)
        .classed(this.options.name, true)
    var update = enter.merge(join)
    var exit = join.exit()
        .remove()
    this.update(update)
    this.enter(enter)
    this.exit(exit)
  }

  render() {
    var self = this
    var color = this.color() || d3.scaleOrdinal().range(d3.schemeCategory10
        .map(function(c) { c = d3.rgb(c); c.opacity = 0.6; return c; }))
    self
      .enter().append('rect')

    self
      .update().select('rect')
      .attr('x', d => d.x0)
      .attr('y', d => d.y0)
      .attr('width', d => d.x1 - d.x0)
      .attr('height', d => d.y1 - d.y0)
      .attr('fill', (d) => { while (d.depth > 1) d = d.parent; return color(d.id); })
  }
}
