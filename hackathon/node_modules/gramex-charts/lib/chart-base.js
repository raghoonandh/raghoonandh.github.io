/* exported Chart, constant, draw */

"use strict"

var svg_ns = "http://www.w3.org/2000/svg"
var global = window

function noop() {}

function constant(val) {
  return function constant() {
    return val
  }
}

function each(object, callback) {
  for (var key in object)
    if (object.hasOwnProperty(key))
      callback(key, object[key])
}

function parse_event(event) {
  var name = '',
      type = event,
      i = event.indexOf('.')
  if (i >= 0) {
    name = event.slice(i + 1) || '*'
    type = event.slice(0, i) || '*'
  }
  return {name: name, type: type}
}

var CHILDREN = '_children',
    CALLBACKS = '_callbacks',
    LINKCOUNT = '_linkcount',
    PROPERTIES = '_properties'

class Dispatcher {
  constructor() {
    Object.defineProperty(this, PROPERTIES, {value: {}, __proto__: null})
    Object.defineProperty(this, CALLBACKS, {value: [], __proto__: null})
  }

  // .prop('x')              // creates a property .x()
  // .x(value)               // sets x to value.
  // .x()                    // returns value.
  // .prop('x', 'y')         // Defines x() storing it in this.y
  // .prop('x', fn)          // Defines x() storing it fn() -- another property
  // .prop({x: x1, y: y1})   // Same as .prop('x', x1).prop('y', y1)
  // .prop(['x', 'y'])       // Same as .prop('x').prop('y')
  // If the target has no value, existing values are propogated
  // Requires .trigger()
  prop(key, variable) {
    var self = this

    // prop() => {all properties and values}
    if (arguments.length == 0) {
      var result = {}
      each(self[PROPERTIES], function(key) { result[key] = self[key]() })
      return result
    }

    // prop(['x', 'y']) => prop('x').prop('y')
    if (Array.isArray(key)) {
      key.forEach(function(val) { self.prop(val) })
      return self
    }
    // prop({x: x1, y: y1}) => prop('x', x1).prop('y', y1)
    if (typeof key == 'object') {
      each(key, self.prop.bind(self))
      return self
    }
    // prop('x') => prop('x', '_x')
    if (arguments.length == 1)
      variable = `_${key}`

    // Get the old value if it exists
    var old_value
    if (typeof self[key] == 'function')
      old_value = self[key]()

    // prop('x', 'a') stores .x() in self.a
    if (typeof variable == 'string') {
      self[key] = function(value) {
        if (arguments.length == 0)
          return self[variable]
        else if (value === null)
          delete self[variable]
        else
          self[variable] = value
        return self.trigger(key, value, key)
      }
    }
    // prop('x', fn) stores .x() in getter-setter fn()
    else if (typeof variable == 'function') {
      self[key] = function(value) {
        if (arguments.length == 0)
          return variable()
        variable(value)
        return self.trigger(key, value, key)
      }
    }
    // prop('x', obj) stores .x() in dictionary, updating it when set
    else if (typeof variable == 'object') {
      self[key] = function(value) {
        if (arguments.length == 0)
          return variable
        // .x(null) clears all keys
        if (value === null)
          each(variable, function(key) { delete variable[key] })
        // .x({key: val}) sets obj[key] = val
        else if (typeof value == 'object')
          each(value, function(key, val) {
            if (val === null)
              delete variable[key]
            else
              variable[key] = val
          })
        // .x(value) sets all existig keys to value
        else
          each(variable, function(key) { variable[key] = value })
        return self.trigger(key, variable, key)
      }
    }
    else
      throw new TypeError(`Invalid value: .prop("${key}", ${variable})`)

    // Store the created property and its target location
    self[PROPERTIES][key] = variable

    // Save the old value into the target if the target has no value
    if (typeof self[key]() == 'undefined' && typeof old_value != 'undefined')
      self[key](old_value)

    return self
  }


  // .call(callback) runs callback(this) and then returns this
  // Useful for chaining
  call(callback) {
    callback(this)
    return this
  }

  // .trigger('x', arg1, arg2, ...)  // trigger all callbacks on x with arguments
  // Requires .on() in CALLBACKS
  trigger(event) {
    var parsed = parse_event(event),
        type = parsed.type,
        args = Array.from(arguments).slice(1),
        self = this
    if (type)
      self.on(`${type}.*`).forEach(function(row) {
        row[2].apply(self, args)
      })
    return self
  }
}

add_namespaced_store(Dispatcher, 'on', CALLBACKS, function(val) { return typeof val == 'function' })

class Container extends Dispatcher {
  constructor() {
    super()
    Object.defineProperty(this, CHILDREN, {value: [], __proto__: null})
    Object.defineProperty(this, LINKCOUNT, {value: 0, __proto__: null, writable: true})
  }

  // container.link('x', [container1, 'x'], [container2, 'x1'], ...) links this
  // container's .x() to container1.x() and container2.x1(). They behave as the
  // same property. In fact, they are stored behind the scenes in container.x().
  link(prop, containers) {
    var self = this
    // container.link(['x', 'y'], [container1, container2])
    // links .x() and .y() across container1 and container2
    if (Array.isArray(prop) && Array.isArray(containers)) {
      prop.forEach(function(prop) {
        var args = [prop]
        for (var i=0, l=containers.length; i<l; i++)
          args.push([containers[i], prop])
        self.link.apply(self, args)
      })
      return self
    }

    var links = Array.from(arguments).slice(1)
    // Create property if required
    if (!self[prop])
      self.prop(prop)
    // Save each linked container's property into this container's property
    links = links.map(function(link) {
      var target = link[0]
      // .link('prop', ['child-name', 'prop'])
      if (typeof target == 'string')
        target = self.child(target) || target
      // .link('prop', [container, 'prop'])
      if (typeof target.prop == 'function')
        target.prop(link[1], self[prop])
      return [target, link[1]]
    })
    // When this container's property changes, trigger all linked containers'
    // properties. Use LINKCOUNT to ensure the events have a unique namespace.
    self.on(`${prop}.link${self[LINKCOUNT]++}`, function(val) {
      for (var i=0, l=links.length; i<l; i++)
        links[i][0].trigger(links[i][1], val, links[i][1])
    })
    return self
  }

  // Create / link specified properties from children
  // .childprop(prop1, prop2, ...)
  childprop() {
    var self = this,
        children =this.child(),
        props = children.map(function(row) { return row[2].prop() })
    Array.from(arguments).forEach(function(prop) {
      self.link([prop], children
          .filter(function(row, i) { return props[i].hasOwnProperty(prop) })
          .map(function(row) { return row[2] }))
    })
    return self
  }
}

add_namespaced_store(Container, 'child', CHILDREN)

// The methods used to determine the size of a node, in order.
var size_methods = {
  // For SVG elements, use the viewBox or computed width/height of nearest SVG parent
  svg: function(node) {
    if (node.namespaceURI && node.namespaceURI == svg_ns) {
      while (!node.nodeName.match(/svg/i))
        node = node.parentNode
      if (node.getAttribute('viewBox'))
        return node.viewBox.baseVal
      else
        return {width: node.width.baseVal.value, height: node.height.baseVal.value}
    }
  },
  bounds: function(node) { if (node.getBoundingClientRect) return node.getBoundingClientRect() }
}

// Return {x, y, width, height} given a chart and its size
//
var attrs = ['top', 'left', 'bottom', 'right']
function padded(chart, dimensions) {
  var pad = chart.padding() || {}
  if (typeof pad == 'function')
    pad = pad(dimensions);
  attrs.forEach(function(attr) {
    if (typeof pad[attr] == 'function')
      pad[attr] = pad[attr](dimensions)
    if (typeof pad[attr] !== 'number')
      pad[attr] = 0
  })
  return {
    left: pad.left,
    top: pad.top,
    width: dimensions.width - pad.left - pad.right,
    height: dimensions.height - pad.top - pad.bottom
  }
}

var name_count = 0
class Chart extends Container {
  constructor(options) {
    super()
    this.options = options || {}
    this.options.name = this.options.name || `name_${name_count++}`
    this.prop(['data', 'update', 'enter', 'exit'])
        .prop('padding', {left: 0, right: 0, top: 0, bottom: 0})
        // .defined() is a function that returns true if a row is to be drawn
        .prop('defined').defined(constant(true))
  }

  // chart.size(node) returns the size of a node by successively trying size methods.
  // If it's unable to get the size, returns {width: 0, height: 0}
  size(node) {
    for (var key in size_methods)
      if (size_methods.hasOwnProperty(key)) {
        var size = size_methods[key](node)
        if (size && size.width > 0 && size.height > 0)
          return padded(this, size)
      }
    var parent = node.parentNode
    if (parent)
      return this.size(parent)
    return {width: 0, height: 0}
  }

  // chart.draw() calls all child .draw() functions, and then this.on('draw') handlers
  // chart.draw() can be called with a string selector, node list or node
  draw(node) {
    // Select a single node as a selector, d3 selection or DOM node
    if (typeof node == 'string')              // selector
      node = document.querySelector(node)
    else if (typeof node.node == 'function')  // d3 selection
      node = node.node()
    else if (!(node instanceof Node))         // node
      throw new TypeError('.draw() needs a single selector, node or d3 selection')
    // Trigger the pre-draw event before starting
    this.trigger('predraw', node, 'predraw')
    // Draw all sub-components
    this.child().forEach(function(row) {
      var name = row[0],
          chart = row[2],
          type = [],
          tag_regex =  /^\s*<\s*(.*?)\s*>\s*$/,
          tag

      row[1].split('.').forEach(function(type_tag) {
        var match = tag_regex.exec(type_tag)
        if (match)
          tag = match[1]
        else
          type.push(type_tag)
      })
      type = type.join('.')

      var selector = `.${name}` + (type ? `.${type}` : ''),
          cls = name + (type ? ` ${type.replace('.', ' ')}` : '')

      // Match or create sub node with the same name
      var ns = node.namespaceURI
      var subnode = node.querySelector(selector)
      // Create the subnode if it doesn't exist
      if (subnode === null) {
        // Use a G or DIV tag if none is specified
        tag = tag || (ns.match(/svg/) ? 'g' : 'div')
        // When creating a tag inside an SVG element, or create an SVG element, use SVG namespace
        // Else do not use a namespace
        if (ns.match(/svg/i) || tag.match(/^svg$/i))
          subnode = document.createElementNS(svg_ns, tag)
        else
          subnode = document.createElement(tag)
        subnode.setAttribute('class', cls)
        node.appendChild(subnode)
      }
      if (typeof chart.draw == 'function')
        chart.draw(subnode)
    })
    // Trigger the draw event when done
    return this.trigger('draw', node, 'draw')
  }

  // .join() is a shortcut for .on('predraw.join', join(...))
  join(selector, data) {
    return this.on('predraw.join', global.join(selector, data))
  }
}

// Returns a method that does a data join on data. For example:
// join('g.vertical', chart.data)
// returns a function(node) that creates joins `g.vertical` with chart.data()
// and adds the enter, update, exit properties to the chart.
global.join = function(selector, data) {
  selector = selector || ''
  var [tag, ...cls] = selector.split('.')
  cls = cls.join(' ')
  return function(node) {
    var name = this.options.name,
        join = d3.select(node)
          .selectAll(selector + '.' + name)
          .data((data || this.data)())
    var enter = join.enter()
        .append(tag || (node.namespaceURI.match(/svg/) ? 'g' : 'div'))
        .classed(cls + ' ' + name, true)
    var exit = join.exit()
        .remove()
    // D3 4.0 uses enter.merge(join). D3 3.0 uses just the join
    this.update(typeof enter.merge == 'function' ? enter.merge(join) : join)
    this.enter(enter)
    this.exit(exit)
  }
}

// Ensure that a single selector=tag.class exists in all joined nodes.
// Call the callback on these selectors as an update.
global.draw = function(selector, callback) {
  var [tag, ...cls] = selector.split('.')
  cls = cls.join(' ')
  if (typeof callback != 'function')
    callback = noop
  return function() {
    var update = this.update()
        .filter(this.defined())
        .each(function() {
          var self = d3.select(this)
          if (self.select(selector).node() === null)
            self.append(tag).classed(cls, true)
        })
        .select(selector)
    callback.call(this, update)
  }
}


// Create cls.method that stores values in attr
function add_namespaced_store(cls, method, attr, check) {
  Object.defineProperty(cls.prototype, method, {value: getter_setter, __proto__: null})

  function getter_setter(event, val, order) {
    var self = this

    // .method([key1, key2], val, order) => .method(key1, val, order).method(key2, val, order)
    if (Array.isArray(event)) {
      event.forEach(function(ev) { getter_setter.bind(self)(ev, val, order)  })
      return self
    }

    // .method({key: val, key:val}) => .method(key, val).method(key, val)
    if (typeof event == 'object') {
      each(event, getter_setter.bind(self))
      return self
    }

    // If event is "type.name", set type, name variables appropriately
    var container = self[attr],
        parsed = parse_event(event || '.'),
        type = parsed.type,
        name = parsed.name,
        all_types = type == '*',
        all_names = name == '*',
        i, row, added, match
    // .method('x')               // returns val for type x, namespace ''
    // .method('x.?')             // returns val for first item of type x
    // .method('x.a')             // returns val of type x, namespace a
    // .method('?.a')             // returns val for first item of namespace a
    // .method('.a'), ('*.a')     // returns list of val with namespace a
    // .method('x.'), ('x.*')     // returns list of val with type x
    if (arguments.length <= 1)
      if (all_types && all_names)
        return container
      else if (all_types)
        return container.filter(function(row) { return row[1] == name })
      else if (all_names)
        return container.filter(function(row) { return row[0] == type })
      else {
        if (name == '?')
          match = container.filter(function(row) { return row[0] == type })
        else if (type == '?')
          match = container.filter(function(row) { return row[1] == name })
        else
          match = container.filter(function(row) { return row[0] == type && row[1] == name })
        return match.length > 0 ? match[0][2] : match[0]
      }

    // .method('x', null)        // clears val type x, namespace ''
    // .method('x.a', null)      // clears val type x, namespace a
    // .method('.a', null)       // clears all vals with namespace a
    else if (val === null) {
      if (all_types && all_names)
        container.length = 0
      else if (all_types)
        for (i=container.length, row; i--;) {
          row = container[i]
          if (row[1] == name)
            container.splice(i, 1)
        }
      else if (all_names)
        for (i=container.length, row; i--;) {
          row = container[i]
          if (row[0] == type)
            container.splice(i, 1)
        }
      else
        for (i=container.length, row; i--;) {
          row = container[i]
          if (row[0] == type && row[1] == name)
            container.splice(i, 1)
        }
    }

    // .method('x', val, order)       // sets type x, namespace '' to val at order
    // .method('x.a', val, order)     // sets type x, namespace a to val at order
    // .method('x', noop, order)      // re-order existing 'x' to order
    else if (type && !all_types) {
      if (typeof check == 'function' && !check(val))
          throw new TypeError(`.${method}("${event}", ${val}) has an invalid value`)
      if (typeof order != 'undefined' && typeof order != 'number')
        throw new TypeError(`.${method}("${event}", ${val}, ${order}): ${order} be a number`)
      for (i=0, added=null, row; row=container[i]; i++)
        if (row[0] == type && row[1] == name) {
          added = row[2] = val === noop ? row[2] : val
          if (typeof order == 'number' && order != i)
            // Move from position `i` to position `order`
            container.splice(order, 0, container.splice(i, 1)[0])
        }
      if (added === null) {
        // insert new row at position `order` -- or at the end
        container.splice(typeof order == 'number' ? order : container.length, 0, [type, name, val])
      }
    }
    else
      throw new TypeError(`.${method}("${event}", ...) is invalid. Use "<type>.<name>"`)

    return self
  }
}
