/* global Chart, constant, draw */
/* exported Axis, VerticalChart, BarChart, LineChart CombChart, AreaChart, ScatterLineChart */

var _axis_map = {
  'top': d3.axisTop,
  'bottom': d3.axisBottom,
  'left': d3.axisLeft,
  'right': d3.axisRight
}
var _curve_map = {
  'linear': d3.curveLinear,
  'linear-closed': d3.curveLinearClosed,
  'step': d3.curveStep,
  'step-after': d3.curveStepAfter,
  'step-before': d3.curveStepBefore,
  'basis': d3.curveBasis,
  'basis-open': d3.curveBasisOpen,
  'basis-closed': d3.curveBasisClosed,
  'bundle': d3.curveBundle,
  'cardinal': d3.curveCardinal,
  'cardinal-open': d3.curveCardinalOpen,
  'cardinal-closed': d3.curveCardinalClosed,
  'monotone': d3.curveMonotoneX
}

var _scale_info = {
  linear: {scale: d3.scaleLinear, ordinal: false, accessor: constant(0) },
  pow:    {scale: d3.scalePow,    ordinal: false, accessor: constant(0) },
  sqrt:   {scale: d3.scaleSqrt,   ordinal: false, accessor: constant(0) },
  log:    {scale: d3.scaleLog,    ordinal: false, accessor: constant(1) },
  time:   {scale: d3.scaleTime,   ordinal: false, accessor: constant(new Date()) },
  point:  {scale: d3.scalePoint,  ordinal: true,  accessor: (d, i) => i},
  band:   {scale: d3.scaleBand,   ordinal: true,  accessor: (d, i) => i}
}


// Returns a function that extends the domain of an axis
// setup: this.xextend = domain_extender(this, 'x', true)   // creates an ordinal extender for x
// usage: this.xextend()                                    // extends .xscale().domain() using data
function domain_extender(self, axis, ordinal) {
  var scalename = `${axis}scale`,
      zero = `${axis}0`,
      zero_val = `${axis}0_value`
  if (ordinal)
    return function() {
      var scale_prop = self[scalename],
          scale = scale_prop(),
          domain = self.data().map(self[axis]())
      if (scale_prop._has_domain) {
        var old_domain = scale.domain(),
            add_values = domain.filter(val => old_domain.indexOf(val) < 0)
        scale.domain(old_domain.concat(add_values))
      } else {
        scale.domain(domain)
        scale_prop._has_domain = true
      }
      return scale
    }
  else
    return function() {
      var scale_prop = self[scalename],
          scale = scale_prop(),
          domain = d3.extent(self.data(), self[axis]())

      // Incorporate the zero value
      var z = self[zero]()
      if (typeof z != 'undefined') {
        if (domain[0] > z)
          domain[0] = z
        if (domain[1] < z)
          domain[1] = z
      } else {
        z = domain[0]
      }
      self[zero_val] = z

      // Extend the domain
      if (scale_prop._has_domain)
        scale.domain(d3.extent([...scale.domain(), ...domain]))
      else {
        scale.domain(domain)
        scale_prop._has_domain = true
      }
      return scale
    }
}

class Axis extends Chart {
  constructor(options) {
    super(options)
    var orient = this.options.orient || 'bottom'
    this.prop('axis').axis(_axis_map[orient]())
        .prop('scale').scale(d3.scaleIdentity())
        .prop('position')
        .on('draw.axis', this.render)
  }
  render(node) {
    var axis = this.axis()
        .scale(this.scale())
    d3.select(node).call(axis)
  }
}

class XYChart extends Chart {
  constructor(options) {
    // Valid options:
    //    .xscale: linear/pow/sqrt/point/band
    //    .yscale: linear/pow/sqrt/point/band
    //    .xaxis: top/left/bottom/right (required for scale)
    //    .yaxis: top/left/bottom/right (required for scale)
    options = Object.assign({xscale: 'linear', yscale: 'linear', xaxis: 'bottom', yaxis: 'left'}, options)
    super(options)

    // Defines .xscale(), .yscale(), .x() and .y() properties with defaults.
    options.x = _scale_info[options.xscale]
    options.y = _scale_info[options.yscale]
    this.prop('xscale').xscale(options.x.scale())
        .prop('x').x(options.x.accessor)
        .prop('yscale').yscale(options.y.scale())
        .prop('y').y(options.y.accessor)

        // .interpolate() is the string interpolation value to use for curves
        .prop('interpolate').interpolate('linear')

        // .layout() creates a .pos object in each row that defines its x, y, width, height
        // .join() creates .enter, .update, .exit properties by joining on this chart's name
        // .axes() moves the axes to the right position (top/bottom/left/right)
        // .render() is an abstract rendering function for this class
        .on('predraw.layout', this.layout)
        .join()
        .on('draw.axes', this.axes)
        .on('draw.render', this.render)

    // Additional properties for continous scales
    if (!options.x.ordinal)
      this.prop('x0')
    if (!options.y.ordinal)
      this.prop('y0')

    // this.xextend() extends .xscale().domain() based on new data
    this.xextend = domain_extender(this, 'x', options.x.ordinal)
    this.yextend = domain_extender(this, 'y', options.y.ordinal)

    this.child('xaxis', new Axis({orient: options.xaxis}))
        .link('xscale', ['xaxis', 'scale'])
    this.child('yaxis', new Axis({orient: options.yaxis}))
        .link('yscale', ['yaxis', 'scale'])

    if (options.labels)
      this.child('labels', new Chart().join('.label'))
          .link(['data', 'defined', 'x', 'y'], ['labels'])
          .child('labels')
            .on('draw.render', this.labels)
  }

  layout(node) {
    var data = this.data(),
        x = this.x(),
        y = this.y(),
        size = this.size(node),
        xscale = this.xextend(),
        yscale = this.yextend(),
        bandwidth, zero_pos

    xscale.range(this.options.yaxis == 'right' ?
      [size.left + size.width, size.width] :
      [size.left, size.left + size.width])
    yscale.range(this.options.xaxis == 'bottom' ?
      [size.top + size.height, size.top] :
      [size.top, size.top + size.height])
    data.forEach((d, i) => {
      d.pos = {
        x: +xscale(x(d, i)),
        y: +yscale(y(d, i))
      }
    })
    if (this.options.x.ordinal) {
      bandwidth = +xscale.bandwidth()
      data.forEach(d => { d.pos.x1 = d.pos.x + bandwidth })
    } else {
      zero_pos = +xscale(this.x0_value)
      data.forEach(d => { d.pos.x1 = zero_pos })
    }
    if (this.options.y.ordinal) {
      bandwidth = +yscale.bandwidth()
      data.forEach(d => { d.pos.y1 = d.pos.y + bandwidth })
    } else {
      zero_pos = +yscale(this.y0_value)
      data.forEach(d => { d.pos.y1 = zero_pos })
    }
  }

  axes(node) {
    var size = this.size(node)
    // Position ordinal axes at the top/left, continous axes at the zero position
    d3.select(node).select('.yaxis')
      .attr('transform', `translate(${this.options.x.ordinal ? size.left : this.xscale()(this.x0_value)},0)`)
    d3.select(node).select('.xaxis')
      .attr('transform', `translate(0,${this.options.y.ordinal ? size.top : this.yscale()(this.y0_value)})`)
  }

  render() {}
}

class VerticalChart extends XYChart {
  constructor(options) {
    options = Object.assign({
      name: 'vertical',
      xscale: 'band',
      yscale: 'linear',
      xaxis: 'bottom',
      yaxis: 'left'
    }, options)
    super(options)
  }
}
VerticalChart.prototype.labels = draw('text.vertical-label', function(update) {
  var y = this.y()
  update
      .attr('transform', d => `translate(${(d.pos.x + d.pos.x1) / 2},${d.pos.y})`)
      .attr('text-anchor', 'middle')
      // If y0_value is undefined, treat y(d) as above y0_value
      .attr('dy', d => y(d) < this.y0_value ? '1em' : '-0.37em')
      .text(d => y(d))
})

class JitterChart extends VerticalChart {}
JitterChart.prototype.render = draw('circle.dot', function(update) {
  // Moves the circle randomly along the horizontal axis
  update.attr('cx', d => d.pos.x + Math.random() * (d.pos.x1 - d.pos.x))
        .attr('cy', d => d.pos.y)
        .attr('r', 1)
})

class BarChart extends VerticalChart {}
BarChart.prototype.render = draw('path.bar', _draw_rect)

class CombChart extends VerticalChart {}
CombChart.prototype.render = draw('path.comb', function(update) {
    update.attr('d', d => `M${(d.pos.x + d.pos.x1)/2},${d.pos.y}V${d.pos.y1}`)
})

class LineChart extends VerticalChart {
  constructor(options) {
    super(options)
    // TODO: this is a hack
    this.join('.line', constant([0]))
  }
  render() {
    var path = d3.line()
      .defined(this.defined())
      .x(d => (d.pos.x + d.pos.x1) / 2)
      .y(d => d.pos.y)
      .curve(_curve_map[this.interpolate()])
    this.enter()
        .append('path')
        .classed('line', true)
    this.update().select('.line')
        .attr('d', path(this.data()))
  }
}

class AreaChart extends LineChart {
  constructor(options) {
    options = Object.assign({xscale: 'point'}, options)
    super(options)
  }
  render() {
    var data = this.data()
    var path = d3.area()
      .defined(this.defined())
      .x(d => (d.pos.x + d.pos.x1) / 2 )
      .y1(d => d.pos.y)
      .curve(_curve_map[this.interpolate()])
    path.y0(this.yscale()(this.y0_value))

    this.enter()
        .append('path')
        .classed('area', true)
    this.update().select('.area')
        .attr('d', path(data))
  }
}


class MatrixChart extends XYChart {
  constructor(options) {
    options = Object.assign({
      name: 'grid',
      xscale: 'band',
      yscale: 'band',
      xaxis: 'top',
      yaxis: 'left'
    }, options)
    super(options)
  }
}

class DotChart extends MatrixChart {}
DotChart.prototype.render = draw('circle.dot', function(update) {
  update.attr('cx', d => (d.pos.x + d.pos.x1) / 2)
        .attr('cy', d => (d.pos.y + d.pos.y1) / 2)
        .attr('r', 1)
})

class GridChart extends MatrixChart {}
GridChart.prototype.render = draw('path.grid', _draw_rect)

class HorizontalChart extends XYChart {
  constructor(options) {
    options = Object.assign({
      name: 'horizontal',
      xscale: 'linear',
      yscale: 'band',
      xaxis: 'top',
      yaxis: 'left'
    }, options)
    super(options)
  }
}

class HorizontalBarChart extends HorizontalChart {}
HorizontalBarChart.prototype.render = draw('path.horizontalbar', _draw_rect)

class HorizontalCombChart extends HorizontalChart {}
HorizontalCombChart.prototype.render = draw('path.horizontalcomb', function(update) {
    update.attr('d', d => `M${d.pos.x},${(d.pos.y + d.pos.y1)/2}H${d.pos.x1}`)
})


class PointChart extends XYChart {
  constructor(options) {
    options = Object.assign({
      name: 'point',
      xscale: 'linear',
      yscale: 'linear',
      xaxis: 'bottom',
      yaxis: 'left'
    }, options)
    super(options)
  }
}

class ScatterChart extends PointChart {}
ScatterChart.prototype.render = draw('circle.dot', function(update) {
  update.attr('cx', d => d.pos.x)
        .attr('cy', d => d.pos.y)
        .attr('r', 1)
})

class ScatterLineChart extends ScatterChart {
  constructor(options) {
    super(options)
    this.join('.line', constant([0]))
  }
  render() {
    var path = d3.line()
      .defined(this.defined())
      .x(d => d.pos.x)
      .y(d => d.pos.y)
      .curve(_curve_map[this.interpolate()])
    this.enter()
        .append('path')
        .classed('line', true)
    this.update().select('.line')
        .attr('d', path(this.data()))
  }
}


function _draw_rect(update) {
  var interpolate = this.interpolate()
  update.attr('d', d => {
    var p = d.pos
    return d3.line().curve(_curve_map[interpolate])([
        [p.x, p.y1],
        [p.x, p.y],
        [p.x1, p.y],
        [p.x1, p.y1]
    ])
  })
}
